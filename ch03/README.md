## 3.1

> 使用恰当的using声明重做1.4.1节和2.6.2节的练习。

略

## 3.2

> 编写一段程序从标准输入中一次读入一整行，然后修改该程序使其一次读入一个词。

[ex3_2.cpp](ex3_2.cpp)

## 3.3

> 请说明string类的输入运算符和getline函数分别是如何处理空白字符的。

string类的输入运算符以所有的空白字符作分隔符，而getline则仅以换行符\n作为分隔符。

getline也可以带有第三参数，第三参数用于指定特定的分隔符。

## 3.4

> 编写一段程序读入两个字符串，比较其是否相等并输出结果。如果不相等，输出较大的那个字符串。改写上述程序，比较输入的两个字符串是否等长，如果不等长，输出长度较大的那个字符串。

[ex3_4.cpp](ex3_4.cpp)

## 3.5

> 编写一段程序从标准输入中读入多个字符串并将它们连接在一起，输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分隔开来。

[ex3_5.cpp](ex3_5.cpp)

## 3.6

> 编写一段程序，使用范围for语句将字符串内的所有字符用X代替。

[ex3_6.cpp](ex3_6.cpp)

## 3.7

> 就上一题完成的程序而言，如果将循环控制变量的类型设为char将发生什么？先估计一下结果，然后实际编程进行验证。

设为char的话，循环处理的字符是字符串每个字符的拷贝，因此不会对string产生影响。

## 3.8

> 分别用while循环和传统的for循环重写第一题的程序，你觉得哪种形式更好呢？为什么？

[ex3_8.cpp](ex3_8.cpp)

C++11引入的范围for更为简洁，当对对象整体进行处理时，使用范围for更简单。但while和for中规中矩，可以处理对象的局部。

## 3.9

> 下面的程序有何作用？它合法吗？如果不合法，为什么？
>
> ```cpp
> string s;
> cout << s[0] << endl;
> ```

将string对象s的第一项输出到cout。

程序不合法，s会被默认初始化为空串，长度为0，访问s[0]是未定义的。

但clang++下可以执行，输出不可见，编译器本身做了处理，语义上是不正确的。

[ex3_9.cpp](ex3_9.cpp)

## 3.10

> 编写一段程序，读入一个包含标点符号的字符串，将标点符号去除后输出字符串剩余的部分。

[ex3_10.cpp](ex3_10.cpp)

## 3.11

> 下面的范围for语句合法吗？如果合法，c的类型是什么？
>
> ```cpp
> cout string s = "Keep out!";
> for(auto &c : s) {/* ... */}
> ```

如果花括号体内没有对c进行修改，那就是合法的，c的类型为const char&。

## 3.12

> 下列vector对象的定义有不正确的吗？如果有，请指出来。对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。
>
> (a)`vector<vector<int>> ivec;`
>
> (b)`vector<string> svec = ivec;`
>
> (c)`vector<string> svec(10, "null");`

a正确，ivec为空；b不正确，类型不一致，亦不能隐式转换；c正确，svec中有10个"null"值的string。

## 3.13

> 下列的vector对象各包含多少个元素？这些元素的值分别是多少？
>
> (a)`vector<int> v1;`
>
> (b)`vector<int> v2(10);`
>
> (c)`vector<int> v3(10, 42);`
>
> (d)`vector<int> v4{10};`
>
> (e)`vector<int> v5{10, 42};`
>
> (f)`vector<string> v6{10};`
>
> (g)`vector<string> v7{10, "hi"};`

v1包含了0个元素。

v2包含了10个元素，值都是0。

v3包含了10个元素，值都是42。

v4包含了一个元素，值为10。

v5包含了两个元素，值为10和42。

v6包含了10个元素，值都是""。

v7包含了10个元素，值都是"hi"。

## 3.14

> 编写一段程序，用cin读入一组整数并把它们存入一个vector对象。

[ex3_14.cpp](ex3_14.cpp)

## 3.15

> 改写上题的程序，不过这次读入的是字符串。

[ex3_15.cpp](ex3_15.cpp)

## 3.16

> 编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来。检验你之前的回答是否正确，如果不对，回过头重新学习3.3.1节直到弄明白错在何处为止。

略

## 3.17

> 从cin读入一组词并把它们存入一个vector对象，然后设法把所有词都改写为大写形式。输出改变后的结果，每个词占一行。

[ex3_17.cpp](ex3_17.cpp)

## 3.18

> 下面的程序合法呢？如果不合法，你准备如何修改？
>
> ```cpp
> vector<int> ivec;
> ivec[0] = 42;
> ```

不合法，因为ivec尺寸为0，直接索引第一项是未定义的。

修改为`ivec.push_back(42);`

## 3.19

> 如果想定义一个含有10个元素的vector对象，所有元素的值都是42，请列举出三种不同的实现方法。哪种方法更好呢？为什么？

`vector<int> v1(10, 42);`

`vector<int> v2 = v1;`

`vector<int> v3{42,42,42,42,42,42,42,42,42,42};`

第一种最好，因为对应的构造器接口最为简洁。

## 3.20

> 读入一组整数并把它们存入一个vector对象，将每对相邻整数的和输出出来。改写你的程序，这次要求先输出第1个和最后1个元素的和，接着输出第2个和倒数第2个元素的和，以次类推。

[ex3_20.cpp](ex3_20.cpp)

## 3.21

> 请使用迭代器重做3.3.3节的第一个练习。

略

## 3.22

> 修改之前那个输出text第一段的程序，首先把text的第一段全都改成大写形式，然后再输出它。

[ex3_22.cpp](ex3_22.cpp)

## 3.23 

> 编写一段程序，创建一个含有10个整数的vector对象，然后使用迭代器将所有元素的值都变成原来的两倍。输出vector对象的内容，检验程序是否正确。

[ex3_23.cpp](ex3_23.cpp)

## 3.24

> 请使用迭代器重做3.3.3节的最后一个练习。

[ex3_24.cpp](ex3_24.cpp)

## 3.25

> 3.3.3节划分分数段的程序是使用下标运算符实现的，请利用迭代器改写程序并实现完全相同的功能。

略

## 3.26

> 在100页的二分搜索程序中，为什么用的是mid = beg + (end - beg) / 2, 而非mid = (beg + end) / 2;？

因为不支持两个迭代器的operator+，operator-则是可以的。

## 3.27

> 假设txt_size是一个无参数的函数，它的返回值是int。请回答下列哪个定义是非法的？为什么？
>
> `unsigned buf_size = 1024;`
>
> (a)`int ia[buf_size];`
>
> (b)`int ia[4*7-14];`
>
> (c)`int ia[txt_size()];`
>
> (d)`char st[11] = "fundamental";`

a不合法，维度值必须得是常量表达式。

b合法。

c不合法，同a。

d不合法，长度不够，C风格字符串长度应该为12（有一个\0结束符）。

## 3.28

> 下列数组中元素的值是什么？
>
> ```cpp
> string sa[10];
> int ia[10];
> int main(){
>     string sa2[10];
>     int ia2[10];
> }
> ```

sa是10个空串，ia是10个0（全局值初始化）。

sa2是10个空串，ia2的10个元素是未定义的（clang++是栈上的垃圾值）。

## 3.29

> 相比于vector来说，数组有哪些缺点，请列举一些。

数组是C的遗产，缺点在于定长，需要编译期确定。数组也没有vector那么多的API。

## 3.30

> 指出下面代码中的索引错误。
>
> ```cpp
> constexpr size_t array_size = 10;
> int ia[array_size];
> for(size_t ix = 1; ix <= array_size; ++ix)
>     ia[ix] = ix;
> ```

索引应该是从0到array_size-1，这里数组越界了。

## 3.31

> 编写一段程序，定义一个含有10个int的数组，令每个元素的值就是其下标值。

[ex3_31.cpp](ex3_31.cpp)

## 3.32

> 将上一题刚刚创建的数组拷贝给另外一个数组。利用vector重写程序，实现类似的功能。

[ex3_32.cpp](ex3_32.cpp)

## 3.33

> 对于104页的程序来说，如果不初始化scores将发生什么？

如果不初始化，就会导致未定义的行为，因为scores不会被初始化，11个成员值不确定。

## 3.34

> 假定p1和p2指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？
>
> `p1 += p2 - p1;`

p1向后移动p2-p1个位置，p2和p1如果合法，那么该语句就合法。

## 3.35

> 编写一段程序，利用指针将数组中的元素置为0。

[ex3_35.cpp](ex3_35.cpp)

## 3.36

> 编写一段程序，比较两个数组是否相等。再写一段程序，比较两个vector对象是否相等。

[ex3_36.cpp](ex3_36.cpp)

## 3.37

> 下面的程序是何含义，程序的输出结果是什么？
>
> ```cpp
> const char ca[] = {'h', 'e', 'l', 'l', 'o'};
> const char *cp = ca;
> while(*cp){
>     cout << *cp << endl;
>     ++cp;
> }
> ```

输出ca字符数组的内容，因为ca的定义方式导致么有\0字符阶段，所以在输出了hello之后还可能会输出未知量的随机的垃圾字符，直到遇到\0为止。

## 3.38

> 在本节中我们提到，将两个指针相加不但是非法的，而且也没什么意义。请问为什么两个指针相加没什么意义?

因为指针本身存储的是地址值，将两个地址值相加当然没什么意义。

## 3.39

> 编写一段程序，比较两个string对象。再编写一段程序，比较两个C风格字符串的内容。

[ex3_39.cpp](ex3_39.cpp)

## 3.40

> 编写一段程序，定义两个字符数组并用字符串字面值初始化它们；接着再定义一个字符数组存放前两个数组连接后的结果。使用strcpy和strcat把前两个数组的内容拷贝到第三个数组中。

[ex3_40.cpp](ex3_40.cpp)

## 3.41

> 编写一段程序，用整型数组初始化一个vector对象。

[ex3_41.cpp](ex3_41.cpp)

## 3.42

>编写一段程序，将含有整数元素的vector对象拷贝给一个整型数组。

[ex3_42.cpp](ex3_42.cpp)

## 3.43

> 编写3个不同版本的程序，令其均能输出ia的元素。版本1使用范围for语句管理迭代过程；版本2和版本3都是用普通的for语句，其中版本2要求用下表运算符，版本3要求用指针。此外，在所有3个版本的程序中都要直接写出数据类型，而不能使用类型别名、auto关键字或decltype关键字。

[ex3_43.cpp](ex3_43.cpp)

## 3.44

> 改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。

[ex3_44.cpp](ex3_44.cpp)

## 3.45

> 再一次改写程序，这次使用auto关键字。

[ex3_45.cpp](ex3_45.cpp)



